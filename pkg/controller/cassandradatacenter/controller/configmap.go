package controller

import (
	"context"
	"fmt"
	cassandraoperatorv1alpha1 "github.com/instaclustr/cassandra-operator/pkg/apis/cassandraoperator/v1alpha1"
	"gopkg.in/yaml.v2"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"regexp"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"strings"
)

// TODO: better name? This "conflicts" with corev1.VolumeMount
type VolumeMount struct {
	Volume    corev1.Volume
	MountPath string
}

type VolumeMounts []*VolumeMount

type configurationResources struct {
	cdc              *cassandraoperatorv1alpha1.CassandraDataCenter
	configMap        *corev1.ConfigMap
	volumeSource     *corev1.ConfigMapVolumeSource
	seedNodesService *corev1.Service
}

func CreateOrUpdateOperatorConfigMap(reconciler *CassandraDataCenterReconciler, cdc *cassandraoperatorv1alpha1.CassandraDataCenter, seedNodesService *corev1.Service) (*VolumeMount, error) {

	// TODO: should these two be wrapped up into a single struct, since they always need to be passed around together to the various addXYZ functions?
	configMap := &corev1.ConfigMap{ObjectMeta: DataCenterResourceMetadata(cdc, "operator-config")}
	volumeSource := &corev1.ConfigMapVolumeSource{LocalObjectReference: corev1.LocalObjectReference{Name: configMap.Name}}

	config := configurationResources{
		cdc:              cdc,
		configMap:        configMap,
		volumeSource:     volumeSource,
		seedNodesService: seedNodesService,
	}

	_, err := controllerutil.CreateOrUpdate(context.TODO(), reconciler.client, config.configMap, func(_ runtime.Object) error {

		if err := addCassandraYamlOverrides(config); err != nil {
			return err
		}

		if err := addCassandraGossipingPropertyFileSnitchProperties(config); err != nil {
			return err
		}

		if err := addCassandraJVMOptions(config); err != nil {
			return err
		}

		addPrometheusSupport(config)

		addCassandraLimits(config)

		if err := controllerutil.SetControllerReference(cdc, configMap, reconciler.scheme); err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	volumeMount := &VolumeMount{
		Volume: corev1.Volume{
			Name:         ConfigMapOperatorVolumeName,
			VolumeSource: corev1.VolumeSource{ConfigMap: config.volumeSource},
		},
		MountPath: ConfigMapOperatorVolumeMountPath,
	}

	return volumeMount, nil
}

func addCassandraJVMOptions(config configurationResources) error {
	if options, err := cassandraJVMOptions(config.cdc); err != nil {
		return err
	} else {
		configMapVolumeAddTextFile(config.configMap, config.volumeSource, ConfigMapJVMMemoryGcOptionsFilePath, *options)
		return nil
	}
}

func addCassandraGossipingPropertyFileSnitchProperties(config configurationResources) error {

	var writer strings.Builder

	_, err := fmt.Fprintln(&writer, "# generated by cassandra-operator")

	if err != nil {
		return err
	}

	properties := map[string]string{
		"dc":           config.cdc.Name,
		"rack":         "rack1",
		"prefer_local": "true",
	}

	if err := writeKeyValueProperties(&writer, properties); err != nil {
		return err
	}

	configMapVolumeAddTextFile(config.configMap, config.volumeSource, ConfigMapCassandraRackDCPropertiesPath, writer.String())

	return nil
}

func addPrometheusSupport(config configurationResources) {
	if config.cdc.Spec.PrometheusSupport {
		configMapVolumeAddTextFile(
			config.configMap,
			config.volumeSource,
			ConfigMapCassandraEnvExporterPath,
			"JVM_OPTS=\"${JVM_OPTS} -javaagent:${CASSANDRA_HOME}/agents/cassandra-exporter-agent.jar=@${CASSANDRA_CONF}/cassandra-exporter.conf\"",
		)
	}
}

func addCassandraLimits(config configurationResources) {
	// tune ulimits
	// unlimited locked memory
	// TODO: move this into the image -- it should be the default
	// TODO: other limits too?
	configMapVolumeAddTextFile(
		config.configMap,
		config.volumeSource,
		ConfigMapCassandraEnvLimitsPath,
		"ulimit -l unlimited\n")
}

func addCassandraYamlOverrides(config configurationResources) error {

	type SeedProvider struct {
		ClassName  string              `yaml:"class_name"`
		Parameters []map[string]string `yaml:"parameters"`
	}

	type CassandraConfig struct {
		ClusterName   string  `yaml:"cluster_name"`
		ListenAddress *string `yaml:"listen_address"`
		RPCAddress    *string `yaml:"rpc_address"`

		SeedProvider []SeedProvider `yaml:"seed_provider"`

		EndpointSnitch string `yaml:"endpoint_snitch"`
	}

	data, err := yaml.Marshal(&CassandraConfig{
		ClusterName: config.cdc.Spec.Cluster,

		ListenAddress: nil, // let C* discover the listen address
		RPCAddress:    nil, // let C* discover the rpc address

		SeedProvider: []SeedProvider{
			{
				ClassName: ConfigMapSeedProviderClass,
				Parameters: []map[string]string{
					{"service": config.seedNodesService.Name},
				},
			},
		},

		EndpointSnitch: ConfigMapEndpointSnitch, // TODO: custom snitch implementation?
	})

	if err != nil {
		return err
	}

	configMapVolumeAddTextFile(config.configMap, config.volumeSource, ConfigMapOperatorOverridesYamlPath, string(data))

	return nil
}

func configMapVolumeAddTextFile(configMap *corev1.ConfigMap, volumeSource *corev1.ConfigMapVolumeSource, path string, data string) {
	encodedKey := regexp.MustCompile("\\W").ReplaceAllLiteralString(path, "_")

	// lazy init
	if configMap.Data == nil {
		configMap.Data = make(map[string]string)
	}

	configMap.Data[encodedKey] = data
	volumeSource.Items = append(volumeSource.Items, corev1.KeyToPath{Key: encodedKey, Path: path})
}
